package fr.openent.crre.helpers;

import fr.openent.crre.model.MailAttachment;
import fr.wseduc.webutils.Either;
import io.vertx.core.Future;
import io.vertx.core.Handler;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import io.vertx.core.logging.Logger;
import io.vertx.core.logging.LoggerFactory;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Function;

public class FutureHelper {

    private static final Logger LOGGER = LoggerFactory.getLogger(FutureHelper.class);

    private FutureHelper() {
    }

    public static Handler<Either<String, JsonArray>> handlerJsonArray(Future<JsonArray> future) {
        return event -> {
            if (event.isRight()) {
                future.complete(event.right().getValue());
            } else {
                LOGGER.error(event.left().getValue());
                future.fail(event.left().getValue());
            }
        };
    }

    /**
     * @deprecated  Replaced by {@link #handlerEitherPromise(Promise)}
     */
    @Deprecated
    public static Handler<Either<String, JsonArray>> handlerJsonArray(Promise<JsonArray> future) {
        return event -> {
            if (event.isRight()) {
                future.complete(event.right().getValue());
            } else {
                LOGGER.error(event.left().getValue());
                future.fail(event.left().getValue());
            }
        };
    }

    /**
     * @deprecated  Replaced by {@link #handlerEitherPromise(Promise)}
     */
    @Deprecated
    public static Handler<Either<String, JsonObject>> handlerJsonObject(Future<JsonObject> future) {
        return event -> {
            if (event.isRight()) {
                future.complete(event.right().getValue());
            } else {
                LOGGER.error(event.left().getValue());
                future.fail(event.left().getValue());
            }
        };
    }

    public static Handler<Either<String, JsonObject>> handlerJsonObject(Promise<JsonObject> future) {
        return event -> {
            if (event.isRight()) {
                future.complete(event.right().getValue());
            } else {
                LOGGER.error(event.left().getValue());
                future.fail(event.left().getValue());
            }
        };
    }

    public static <L, R> Handler<Either<L, R>> handlerEitherPromise(Promise<R> promise) {
        return event -> {
            if (event.isRight()) {
                promise.complete(event.right().getValue());
            } else {
                String errormessage = event.left().getValue() != null ? event.left().getValue().toString() : "";
                String message = String.format("[CRRE@%s::handlerEitherPromise]: %s",
                        FutureHelper.class.getSimpleName(), errormessage);
                LOGGER.error(message);
                promise.fail(errormessage);
            }
        };
    }

    /**
     * Allows you to generate futures and complete them sequentially from a function and a list
     * For each element we will call the function that will generate a future
     * Returns a list containing the future generated
     * This function makes it possible to generate the future sequentially, that is to say that the next future is only generated when the previous one is finished
     *
     * @param function the function that will generate future
     * @param elements list of elements allowing to generate the future
     * @param failWhenError when true, one of the future generated fails
     * @param <L> the typing of the elements provides
     * @param <R> the typing of the futures generated by the function
     * @return a list containing the future generated
     */
    public static <L, R> Future<List<Future<R>>> compositeSequential(Function<L, Future<R>> function, List<L> elements, boolean failWhenError) {
        Promise<List<Future<R>>> promise = Promise.promise();
        List<Future<R>> futureList = new ArrayList<>();

        Promise<Void> init = Promise.promise();
        Future<Void> current = init.future();

        for (L element: elements) {
            current = current.compose(result -> {
                Promise<Void> otherPromise = Promise.promise();

                Future<R> future = function.apply(element)
                        .onSuccess(res -> otherPromise.complete())
                        .onFailure(otherPromise::fail);

                futureList.add(future);

                return otherPromise.future();
            });
        }
        if (failWhenError) {
            current.onSuccess(res -> promise.complete(futureList))
                    .onFailure(promise::fail);
        } else {
            current.onComplete(ar -> promise.complete(futureList));
        }
        init.complete();

        return promise.future();
    }
}

